q
user
user.reload.gold?
q
user.reload.all_points
user.reload
continue
user.reload.standard?
user.reload
q
self.may_to_gold?(tier: :gold)
q
self.may_to_gold?(tier: :gold)
q
self.may_to_gold?('gold')
self.may_to_gold?(:gold)
q
self
self.may_to_platinum?
self.may_to_gold?
self
q
user.to_gold!
user.may_to_gold?
q
user.to_gold
user.may_to_gold?('goldasdf')
user.may_to_gold?('gold')
user.may_to_gold?
q
user.may_to_gold?
q
user.all_points
user.may_to_gold?
q
user.all_points
user.may_to_gold?
user.may_to_platinum?
user.may_to_standard?
user.may_to_gold?
q
user.reload
user.to_gold!
user.all_points
continue
user
user.to_gold!
user.all_points
q
user.all_points
user.all-points
user.to_gold
user.gold!
q
userq
user
self
q
transactions.first.update(created_at: 65.days.ago)
transactions.first
transactions
q
Transaction.count
transactions
continue
should
comparison
continue
should
comparison
continue
should
points_transaction_scope.send(values['caller']).send(values['extractor'])
values.is_a?(Array)
q
values
user.send(arg_table.underscore.pluralize)
table
continue
q
should
comparison
continue
should
comparison
continue
q
scope = user.send(arg_table.underscore.pluralize).calculated
user.send(arg_table.underscore.pluralize).calculated.count
user.send(arg_table.underscore.pluralize).calculated
user.send(arg_table.underscore.pluralize).not.used
user.send(arg_table.underscore.pluralize)
q
scope
q
table_klass.new.is_a?(PointTransaction)
table_klass.new
table_klass.new.class
reward_type.is_a?(PointTransaction)
reward_type.class
reward_type
q
table_klass.new.class
table_klass.new.is_a?(PointTransaction)
p.is_a?(PointTransaction)
p.class
p = pt.new
pt
pt.class
pt = PointTransaction
PointTransaction
table_klass.klass
table_klass.class
table_klass.table_name
table_klass.is_a?(PointTransaction)
table_klass
q
table_klass
PointTransaction.is_a?(PointTransaction)
PointTransaction.class
klass
klass.class.class_name
klass.class_name
klass.class.name
klass.class
klass.is_a?(PointTransaction)
klass = table.table_name.classify.constantize
table.table_name.classify.constantize.is_a?(PointTransaction)
table.table_name.classify.constantize.class.is_a?(PointTransaction)
table.table_name.classify.constantize.is_a?(PointTransaction)
table.table_name.classify.constantize.class
table.table_name.classify.constantize
table.table_name
u.klass
u = User.arel_table
table.class.name
table.class_name
table
table[:klass]
table.@klass
table.klass
table.name
table.klass
table.as_json
table.klass_name
table.klass
table.table_name
table.klass
table.class
table
q
RewardTransaction.first.rewardable
RewardTransaction.first
RewardTransaction.count
continue
reward_points?
continue
reward_points?
continue
comparison
should
continue
q
eval('100')
eval('Time.now.utc.month')
Time.now.utc
q
points_transaction_scope.send(values['caller']).send('month')
points_transaction_scope.send(values['caller']).send(values['extractor'])
values['extractor']
points_transaction_scope.send(values['caller'])
points_transaction_scope.send(values['caller']).send(values['extractor'])
values
continue
values
q
points_transaction_scope.send('birthday').send('month')
points_transaction_scope.send('birthday')
points_transaction_scope.send('birthday', :to_date)
points_transaction_scope.send('birthday', :month)
points_transaction_scope.send('birthday')
values
points_transaction_scope
continue
points_transaction_scope
continue
scoped
continue
scoped
q
table.class
table
arg_table
scoped
continue
RewardsIssuingRule.last
RewardsIssuingRule.count
scoped
condition
arg_table
continue
user_reward
continue
user_reward
q
user_reward
q
user_reward
q
reward_transactions.map(&:rewardable)
Reward.points100.first
user_reward
q
user_reward
q
reward
Reward.points100.first
reward
reward_transactions.map(&:rewardable)
q
reward_transactions.map(&:rewardable)
reward_transaction.map(&:rewardable)
reward_transactions
q
Reward.airport.first
Reward.airport
Reward.last
reward_transaction.reward
reward_transaction
reward_transaction.reward
q
user.reload.reward_transactions.first.point_transactions.count
user.reload.reward_transactions.first.point_transactions
user.reload.reward_transactions.first
user.reload.reward_transactions
user.reload.reward_transactions.count
continue
user.reload.reward_transactions.count
continue
q
user.reload.reward_transactions.count
continue
q
self.point_reward_transactions
self.reward_transactions
self
continue
q
self.reward_transactions
self
RewardTransaction.count
self
continue
q
retran
continue
